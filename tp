#!/usr/bin/env python
import os
import time
import re
import glob
import time
import sys
import asyncio
import subprocess
from math import ceil, sqrt
from io import BytesIO

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from prompt_toolkit import PromptSession
from prompt_toolkit.validation import Validator, ValidationError
from prompt_toolkit.key_binding import KeyBindings
from prompt_toolkit.completion import Completer, Completion
from prompt_toolkit.shortcuts.prompt import CompleteStyle

from base64 import standard_b64encode
from collections import defaultdict
import array, fcntl, termios # for get_terminal_size

plt.style.use(['dark_background', 'fast'])
bindings = KeyBindings()
mpl_settings = "/tmp/jackplots.txt"
plot_name="/tmp/jackplotname.txt"
runlist = "/tmp/runlist.txt"
with open(mpl_settings, "w") as f:
    f.write("")
old_matches = []
px = 1/plt.rcParams['figure.dpi']  # pixel in inches

def get_terminal_size():
    buf = array.array('H', [0, 0, 0, 0])
    fcntl.ioctl(1, termios.TIOCGWINSZ, buf)
    return buf[2], buf[3]

async def read_csv(file: str):
    return pd.read_csv(file, dtype=np.float16, engine="pyarrow")


async def load():
    global runs, keys, matches
    with open(runlist, "w") as f:
        f.write("")
    runs = {}
    keys = None
    matches = []
    labels = []
    futures = []
    read_file = False
    for f in sys.argv[1:]:
        metrics_file = os.path.join(os.path.join("", f),"metrics.csv")
        results_file = os.path.join(os.path.join("", f),"results.txt")
        if os.path.exists(metrics_file):
            file = metrics_file
        elif os.path.exists(results_file): 
            file = results_file
        else:
            print(f"WARNING: {metrics_file} and {results_file} not found")
            continue
        try:
            label = os.path.basename(f)
            futures.append(read_csv(file))
            labels.append(label)

            # bug: all runs will appear after reload
            with open(runlist, "a") as f:
                f.write(f"{label}\n")
            read_file = True
        except:
            raise OSError(f"Could not read {file}")
    if not read_file:
        raise OSError(f"Could not read any file")
    run_data = await asyncio.gather(*futures)
    assert len(labels) == len(run_data)

    runs = dict(zip(labels, run_data))
    keys = list(set().union(*[v.keys() for v in runs.values()]))

# KITTY Graphics
def serialize_gr_command(**cmd):
    payload = cmd.pop('payload', None)
    cmd = ','.join(f'{k}={v}' for k, v in cmd.items())
    ans = []
    w = ans.append
    w(b'\033_G'), w(cmd.encode('ascii'))
    if payload:
        w(b';')
        w(payload)
    w(b'\033\\')
    return b''.join(ans)


def write_chunked(**cmd):
    data = standard_b64encode(cmd.pop('data'))
    while data:
        chunk, data = data[:4096], data[4096:]
        m = 1 if data else 0
        sys.stdout.buffer.write(serialize_gr_command(payload=chunk, m=m,
                                                    **cmd))
        sys.stdout.flush()
        cmd.clear()

def delete_all_imgs(**cmd):
    sys.stdout.buffer.write(serialize_gr_command(payload=None,a="d", **cmd))
    sys.stdout.flush()


def apply_settings_before_plot():
    # run mpl commands before plotting
    with open(mpl_settings) as f:
        for line in f:
            line = line.strip().split()
            if line[0] == "style":
                if line[1] == "dark":
                    plt.style.use(["dark_background", "fast"])
                else:
                    plt.style.use(["classic", "fast"])

def apply_settings_to_ax(ax):
    with open(mpl_settings) as f:
        for line in f:
            line = line.strip().split()
            if len(line) not in (1, 2, 3):
                continue
            
            if line[0] == "ylog":
                ax.set_yscale('log')
            if line[0] == "xmin":
                ax.set_xlim(max(ax.get_xlim()[0],float(line[1])))
            elif line[0] == "ymin":
                ax.set_ylim(max(ax.get_ylim()[0],float(line[1])))
            elif line[0] == "xmax":
                ax.set_xlim(None, min(ax.get_xlim()[1],float(line[1])))
            elif line[0] == "ymax":
                ax.set_ylim(None, min(ax.get_ylim()[1],float(line[1])))
            elif line[0] == "legend":
                ax.legend(loc=" ".join(line[1:])) 

def plot(ax, metrics: dict, metric: str, label: str):
    if metric not in metrics.keys():
        return
    ax.plot(metrics[metric], label=label, linewidth=4)

    # Skip processing plot statistics if there are none
    if not metric.endswith("_mean"):
        ax.set_title(metric)
        return
    ax.set_title(metric[:-5])
    # plot shaded area between min and max of metric
    min_met = metric[:-5]+"_min"
    max_met = metric[:-5]+"_max"
    std_met = metric[:-5]+"_std"
    ax.fill_between(list(range(len(metrics[metric]))),
                    metrics[min_met],
                    metrics[max_met],alpha=0.2)
    if std_met not in metrics.keys():
        return
    # plot std if exists
    xs = list(range(len(metrics[metric])))
    std_mins = [max(_min, mean-sqrt(std)) for _min, mean, std in 
            zip(metrics[min_met], metrics[metric], metrics[std_met])]
    std_maxes = [min(_max, mean+sqrt(std)) for _max, mean, std in 
            zip(metrics[max_met], metrics[metric], metrics[std_met])]
    ax.fill_between(xs, std_mins, std_maxes, alpha=0.2) 

def compute_num_rows_and_cols(num_metrics: int):
    """Determines the size of the graph grid"""
    if num_metrics % 2 == 0 and num_metrics % 6 != 0:
        num_cols = 2
    else:
        num_cols = min(num_metrics, 3)
    num_rows = ceil(num_metrics / num_cols)
    return num_rows, num_cols

def get_ax(axes, i, num_rows, num_cols):
    """Gets axis i from matrix of axes"""
    r, c = i // num_cols, i % num_cols
    ax = 0
    # matplotlib doesn't make 2d grid a dimension is len 1
    if num_cols==1:
        ax = axes
    elif num_rows==1:
        ax = axes[c]
    else:
        ax = axes[r,c]
    return ax


# Image generation
def make_grid(unfiltered_metrics: list):
    if len(unfiltered_metrics) == 0:
        print("no metrics")
        return None
    unfiltered_metrics.sort()
    metrics = [m for m in unfiltered_metrics if not m.endswith("_min") and not m.endswith("_max") and not m.endswith("_std")]
    
    num_rows, num_cols = compute_num_rows_and_cols(len(metrics))
    # users can change visible runs by commenting or deleting lines in runlist
    with open(runlist) as f:
        runs_to_plot = [r.strip() for r in f.readlines() if not r.startswith("#")]

    apply_settings_before_plot()

    size = get_terminal_size()
    xsize = (size[0]*px) - 1
    ysize = (size[1]*px) - 1 if num_rows <= 2 else ((num_rows * size[1]*px)/2) - 1
    fig, axes = plt.subplots(num_rows, num_cols, figsize=(xsize, ysize))
    for i, metric in enumerate(metrics):
        ax = get_ax(axes, i, num_rows, num_cols)

        for run in runs_to_plot:
            label = None if len(runs) < 2 else run
            plot(ax, runs[run], metric, label)
            
        if len(runs) > 1:
            ax.legend(loc="upper left")

        apply_settings_to_ax(ax)
    return 1


def update_and_draw_grid():
    global matches 
    if len(matches) == 0:
        return
    os.system("clear")
    # move cursor to bottom of screen
    #for i in range(50):
    #    print()
    plt.clf()
    grid = make_grid([metric for metric in matches])
    if grid is not None:
        stream = BytesIO()
        stream.seek(0)
        plt.savefig(stream, format="png")
        data = stream.getvalue()
        delete_all_imgs()
        write_chunked(a='T', f=100, data=data)
        plt.close("all")
        print()

def get_matches(text):
    return list(filter(lambda x: re.match(text, x), keys))

@bindings.add('?')
def _(event):
    subprocess.run(f"vim {mpl_settings}", shell=True)
    update_and_draw_grid()
    event.app.exit()

@bindings.add('\'')
def _(event):
    subprocess.run(f"vim {runlist}", shell=True)
    update_and_draw_grid()
    event.app.exit()

@bindings.add('/')
def _(event):
    with open(plot_name, "w") as f:
        f.write("")
    subprocess.run(["vim", plot_name])
    with open(plot_name) as f:
        name = f.read().strip()
        if name:
            plt.savefig(name, format="png")
    print("plot saved to", name)
    event.app.exit()

class RegexCompleter(Completer):
    def get_completions(self, document, complete_event):
        matches = get_matches(document.text)
        for match in matches:
            yield Completion(match, start_position=-len(document.text))


async def main():
    global matches, old_matches, text, old_text
    session = PromptSession( key_bindings=bindings, completer=RegexCompleter(),
                           complete_style=CompleteStyle.READLINE_LIKE)

    while True:
        try:
            global text, old_text
            time.sleep(0.1)
            old_text = text
            text = await asyncio.wait_for(session.prompt_async('> ', vi_mode=True,  default='.*'), timeout=300)
        except KeyboardInterrupt:  # Ctrl-C
            continue
        except EOFError:           # Ctrl-D
            break
        except asyncio.TimeoutError:
            print("\r" + " "*40, end="")
            await load()
            if old_text:
                matches = get_matches(old_text)
                update_and_draw_grid()
        else:
            if text:
                matches = get_matches(text)            
                if old_matches != matches:
                    update_and_draw_grid()
                    old_matches = matches.copy()

if __name__ == '__main__':
    text = None
    asyncio.run(load())
    asyncio.run(main())
